from collections import namedtuple
import getpass
from pathlib import Path
import platform
import re
import shutil
import subprocess
import sys

from downward.experiment import FastDownwardExperiment
from downward.reports import PlanningReport
from downward.reports.absolute import AbsoluteReport
from downward.reports.compare import ComparativeReport
from downward.reports.scatter import ScatterPlotReport
from downward.reports.taskwise import TaskwiseReport
from lab import tools
from lab.environments import TetralithEnvironment, LocalEnvironment
from lab.experiment import ARGPARSER
from lab.reports import Attribute, geometric_mean


# Silence import-unused messages. Experiment scripts may use these imports.
assert LocalEnvironment and ScatterPlotReport and TaskwiseReport


DIR = Path(__file__).resolve().parent
NODE = platform.node()
REMOTE = re.match(r"tetralith\d+\.nsc\.liu\.se|n\d+", NODE)

User = namedtuple("User", ["scp_login", "remote_repos"])
USERS = {
    "jendrik": User(
        scp_login="nsc",
        remote_repos="/proj/dfsplan/users/x_jense/",
    ),
}
USER = USERS.get(getpass.getuser())


def parse_args():
    ARGPARSER.add_argument("--tex", action="store_true", help="produce LaTeX output")
    ARGPARSER.add_argument(
        "--relative", action="store_true", help="make relative scatter plots"
    )
    return ARGPARSER.parse_args()


ARGS = parse_args()
TEX = ARGS.tex
RELATIVE = ARGS.relative

EVALUATIONS_PER_TIME = Attribute(
    "evaluations_per_time", min_wins=False, function=geometric_mean, digits=1
)

# Generated by "./suites.py satisficing" in aibasel/downward-benchmarks repo.
# fmt: off
SUITE_SATISFICING = [
    "agricola-sat18-strips", "airport", "assembly", "barman-sat11-strips",
    "barman-sat14-strips", "blocks", "caldera-sat18-adl",
    "caldera-split-sat18-adl", "cavediving-14-adl", "childsnack-sat14-strips",
    "citycar-sat14-adl", "data-network-sat18-strips", "depot", "driverlog",
    "elevators-sat08-strips", "elevators-sat11-strips", "flashfill-sat18-adl",
    "floortile-sat11-strips", "floortile-sat14-strips", "freecell",
    "ged-sat14-strips", "grid", "gripper", "hiking-sat14-strips",
    "logistics00", "logistics98", "maintenance-sat14-adl", "miconic",
    "miconic-fulladl", "miconic-simpleadl", "movie", "mprime", "mystery",
    "nomystery-sat11-strips", "nurikabe-sat18-adl", "openstacks",
    "openstacks-sat08-adl", "openstacks-sat08-strips",
    "openstacks-sat11-strips", "openstacks-sat14-strips", "openstacks-strips",
    "optical-telegraphs", "organic-synthesis-sat18-strips",
    "organic-synthesis-split-sat18-strips", "parcprinter-08-strips",
    "parcprinter-sat11-strips", "parking-sat11-strips", "parking-sat14-strips",
    "pathways", "pegsol-08-strips", "pegsol-sat11-strips", "philosophers",
    "pipesworld-notankage", "pipesworld-tankage", "psr-large", "psr-middle",
    "psr-small", "rovers", "satellite", "scanalyzer-08-strips",
    "scanalyzer-sat11-strips", "schedule", "settlers-sat18-adl",
    "snake-sat18-strips", "sokoban-sat08-strips", "sokoban-sat11-strips",
    "spider-sat18-strips", "storage", "termes-sat18-strips",
    "tetris-sat14-strips", "thoughtful-sat14-strips", "tidybot-sat11-strips",
    "tpp", "transport-sat08-strips", "transport-sat11-strips",
    "transport-sat14-strips", "trucks", "trucks-strips",
    "visitall-sat11-strips", "visitall-sat14-strips",
    "woodworking-sat08-strips", "woodworking-sat11-strips", "zenotravel",
]

SUITE_UNSOLVABLE = [
    "3unsat",
    "bag-barman",
    "bag-gripper",
    "bag-transport",
    "bottleneck",
    "cave-diving",
    "chessboard-pebbling",
    # "diagnosis",  # Translator produces conditional effects.
    "document-transfer",
    "mystery",
    "over-nomystery",
    "over-rovers",
    "over-tpp",
    "pegsol",
    "pegsol-row5",
    "sliding-tiles",
    "tetris",
    "unsat-nomystery",
    "unsat-rovers",
    "unsat-tpp",
]

SUITE_OPTIMAL_STRIPS = [
    "agricola-opt18-strips", "airport", "barman-opt11-strips",
    "barman-opt14-strips", "blocks", "childsnack-opt14-strips",
    "data-network-opt18-strips", "depot", "driverlog",
    "elevators-opt08-strips", "elevators-opt11-strips",
    "floortile-opt11-strips", "floortile-opt14-strips", "freecell",
    "ged-opt14-strips", "grid", "gripper", "hiking-opt14-strips",
    "logistics00", "logistics98", "miconic", "movie", "mprime",
    "mystery", "nomystery-opt11-strips", "openstacks-opt08-strips",
    "openstacks-opt11-strips", "openstacks-opt14-strips",
    "openstacks-strips", "organic-synthesis-opt18-strips",
    "organic-synthesis-split-opt18-strips", "parcprinter-08-strips",
    "parcprinter-opt11-strips", "parking-opt11-strips",
    "parking-opt14-strips", "pathways", "pegsol-08-strips",
    "pegsol-opt11-strips", "petri-net-alignment-opt18-strips",
    "pipesworld-notankage", "pipesworld-tankage", "psr-small", "rovers",
    "satellite", "scanalyzer-08-strips", "scanalyzer-opt11-strips",
    "snake-opt18-strips", "sokoban-opt08-strips",
    "sokoban-opt11-strips", "spider-opt18-strips", "storage",
    "termes-opt18-strips", "tetris-opt14-strips",
    "tidybot-opt11-strips", "tidybot-opt14-strips", "tpp",
    "transport-opt08-strips", "transport-opt11-strips",
    "transport-opt14-strips", "trucks-strips", "visitall-opt11-strips",
    "visitall-opt14-strips", "woodworking-opt08-strips",
    "woodworking-opt11-strips", "zenotravel",
]

DOMAIN_GROUPS = {
    "airport": ["airport"],
    "barman": ["barman-opt11-strips", "barman-opt14-strips"],
    "blocks": ["blocks"],
    "childsnack": ["childsnack-opt14-strips"],
    "depot": ["depot"],
    "driverlog": ["driverlog"],
    "elevators": ["elevators-opt08-strips", "elevators-opt11-strips"],
    "floortile": ["floortile-opt11-strips", "floortile-opt14-strips"],
    "freecell": ["freecell"],
    "ged": ["ged-opt14-strips"],
    "grid": ["grid"],
    "gripper": ["gripper"],
    "hiking": ["hiking-opt14-strips"],
    "logistics": ["logistics98", "logistics00"],
    "miconic": ["miconic"],
    "movie": ["movie"],
    "mprime": ["mprime"],
    "mystery": ["mystery"],
    "nomystery": ["nomystery-opt11-strips"],
    "openstacks": [
        "openstacks-strips",
        "openstacks-opt08-strips",
        "openstacks-opt11-strips",
        "openstacks-opt14-strips",
    ],
    "parcprinter": ["parcprinter-08-strips", "parcprinter-opt11-strips"],
    "parking": ["parking-opt11-strips", "parking-opt14-strips"],
    "pathways": ["pathways", "pathways-noneg"],
    "pegsol": ["pegsol-08-strips", "pegsol-opt11-strips"],
    "pipes-nt": ["pipesworld-notankage"],
    "pipes-t": ["pipesworld-tankage"],
    "psr-small": ["psr-small"],
    "rovers": ["rovers"],
    "satellite": ["satellite"],
    "scanalyzer": ["scanalyzer-08-strips", "scanalyzer-opt11-strips"],
    "sokoban": ["sokoban-opt08-strips", "sokoban-opt11-strips"],
    "storage": ["storage"],
    "tetris": ["tetris-opt14-strips"],
    "tidybot": ["tidybot-opt11-strips", "tidybot-opt14-strips"],
    "tpp": ["tpp"],
    "transport": [
        "transport-opt08-strips",
        "transport-opt11-strips",
        "transport-opt14-strips",
    ],
    "trucks": ["trucks-strips"],
    "visitall": ["visitall-opt11-strips", "visitall-opt14-strips"],
    "woodwork": ["woodworking-opt08-strips", "woodworking-opt11-strips"],
    "zenotravel": ["zenotravel"],
    # IPC 2018:
    "agricola": ["agricola", "agricola-opt18-strips"],
    "data-network": ["data-network", "data-network-opt18-strips"],
    "organic-split": [
        "organic-synthesis-split",
        "organic-synthesis-split-opt18-strips",
    ],
    "organic": ["organic-synthesis", "organic-synthesis-opt18-strips"],
    "petri-net": ["petri-net-alignment", "petri-net-alignment-opt18-strips"],
    "snake": ["snake", "snake-opt18-strips"],
    "spider": ["spider", "spider-opt18-strips"],
    "termes": ["termes", "termes-opt18-strips"],
}
# fmt: on


DOMAIN_RENAMINGS = {}
for group_name, domains in DOMAIN_GROUPS.items():
    for domain in domains:
        DOMAIN_RENAMINGS[domain] = group_name


def group_domains(run):
    old_domain = run["domain"]
    run["domain"] = DOMAIN_RENAMINGS[old_domain]
    run["problem"] = old_domain + "-" + run["problem"]
    return run


def get_repo_base() -> Path:
    """Get base directory of the repository, as an absolute path.

    Search upwards in the directory tree from the main script until a
    directory with a subdirectory named ".git" or ".hg" is found.

    Abort if the repo base cannot be found."""
    path = Path(tools.get_script_path())
    while path.parent != path:
        if any((path / d).is_dir() for d in [".git", ".hg"]):
            return path
        path = path.parent
    sys.exit("repo base could not be found")


def remove_file(path: Path):
    try:
        path.unlink()
    except FileNotFoundError:
        pass


def add_evaluations_per_time(run):
    evaluations = run.get("evaluations")
    time = run.get("search_time")
    if evaluations is not None and evaluations >= 100 and time:
        run["evaluations_per_time"] = evaluations / time
    return run


def _get_exp_dir_relative_to_repo():
    repo_name = get_repo_base().name
    script = Path(tools.get_script_path())
    script_dir = script.parent
    rel_script_dir = script_dir.relative_to(get_repo_base())
    expname = script.stem
    return repo_name / rel_script_dir / "data" / expname


def add_scp_step(exp):
    remote_exp = Path(USER.remote_repos) / _get_exp_dir_relative_to_repo()
    exp.add_step(
        "scp-eval-dir",
        subprocess.call,
        [
            "scp",
            "-r",  # Copy recursively.
            "-C",  # Compress files.
            f"{USER.scp_login}:{remote_exp}-eval",
            f"{exp.path}-eval",
        ],
    )


def fetch_algorithm(exp, expname, algo, *, new_algo=None):
    """Fetch (and possibly rename) a single algorithm from *expname*."""
    new_algo = new_algo or algo

    def rename_and_filter(run):
        if run["algorithm"] == algo:
            run["algorithm"] = new_algo
            run["id"][0] = new_algo
            return run
        return False

    exp.add_fetcher(
        f"data/{expname}-eval",
        filter=rename_and_filter,
        name=f"fetch-{new_algo}-from-{expname}",
        merge=True,
    )


def add_absolute_report(exp, *, name=None, outfile=None, **kwargs):
    report = AbsoluteReport(**kwargs)
    if name and not outfile:
        outfile = f"{name}.{report.output_format}"
    elif outfile and not name:
        name = Path(outfile).name
    elif not name and not outfile:
        name = f"{exp.name}-abs"
        outfile = f"{name}.{report.output_format}"

    if not Path(outfile).is_absolute():
        outfile = Path(exp.eval_dir) / outfile

    exp.add_report(report, name=name, outfile=outfile)
    if not REMOTE:
        exp.add_step(f"open-{name}", subprocess.call, ["xdg-open", outfile])
    exp.add_step(f"publish-{name}", subprocess.call, ["publish", outfile])


class CommonExperiment(FastDownwardExperiment):
    def __init__(self, extra_parser=None, **kwargs):
        super().__init__(**kwargs)

        self.add_step("build", self.build)
        self.add_step("start", self.start_runs)
        self.add_fetcher(name="fetch")

        if not REMOTE:
            self.add_step(
                "remove-eval-dir", shutil.rmtree, self.eval_dir, ignore_errors=True
            )
            add_scp_step(self)

        self.add_parser(self.EXITCODE_PARSER)
        self.add_parser(self.TRANSLATOR_PARSER)
        if extra_parser:
            self.add_parser(DIR / extra_parser)
        self.add_parser(self.PLANNER_PARSER)

    def _add_runs(self):
        """
        Example showing how to modify the automatically generated runs.

        This uses private members, so it might break between different
        versions of Lab.

        """
        FastDownwardExperiment._add_runs(self)
        for run in self.runs:
            command = run.commands["planner"]
            # Slightly raise soft limit for output to stdout.
            command[1]["soft_stdout_limit"] = 1.5 * 1024


import json
import logging

class UpperBoundsReport(PlanningReport):
    def get_text(self):
        if len(self.algorithms) != 1:
            logging.critical("report needs exactly one algorithm")
        bounds = {}
        for (domain, problem), runs in sorted(self.problem_runs.items()):
            run = runs[0]
            cost = run.get("cost")
            if cost is not None:
                cost = int(cost)
            bounds[f"{domain}:{problem}"] = cost
        return json.dumps(bounds, indent=2)


class CollectPlans(PlanningReport):
    @staticmethod
    def get_plan_cost(plan):
        with open(plan) as f:
            for line in f:
                match = re.match(r"; cost = (\d+) .*", line)
                if match:
                    cost = int(match.group(1))
                    return cost

    @staticmethod
    def get_cheapest_plan(run_dir):
        # Due to a bug (that affects an old experiment, but that's fixed by now), we can't just use the last sas_plan.
        # In any case, it's good to parse the plan cost and check that it matches the "cost" attribute.
        plans = list(run_dir.glob("sas_plan.*"))
        if not plans:
            return None
        plans.sort(key=CollectPlans.get_plan_cost)
        return plans[0]

    def write(self):
        if len(self.algorithms) != 1:
            logging.critical("report needs exactly one algorithm")
        exp_dir = Path(self.eval_dir.replace("-eval", ""))
        assert exp_dir.is_dir()
        bounds = {}
        for (domain, problem), runs in self.problem_runs.items():
            run = runs[0]
            run_dir = exp_dir / run["run_dir"]
            print(run_dir)
            cheapest_plan = CollectPlans.get_cheapest_plan(run_dir)
            min_cost = CollectPlans.get_plan_cost(cheapest_plan) if cheapest_plan else None
            bounds[f"{domain}:{problem}"] = min_cost
            if cheapest_plan is None:
                continue
            if run.get("cost") != min_cost:
                print("Cost discrepancy for ", domain, problem, run.get("cost"), min_cost)
            domain_dir = Path(self.outfile) / domain
            domain_dir.mkdir(parents=True, exist_ok=True)
            domain_file = run_dir / "domain.pddl"
            problem_file = run_dir / "problem.pddl"
            shutil.copy2(domain_file, domain_dir / domain_file.resolve().name)
            shutil.copy2(problem_file, domain_dir / problem_file.resolve().name)
            shutil.copy2(cheapest_plan, domain_dir / f"{problem}.plan")
        with open(Path(self.outfile) / "bounds.json", "w") as f:
            json.dump(bounds, f, indent=2)
